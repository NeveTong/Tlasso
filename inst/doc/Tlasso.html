<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Xiang Lyu, Will Wei Sun, Zhaoran Wang, Han Liu, Jian Yang, Guang Cheng." />

<meta name="date" content="2022-01-31" />

<title>Package “Tlasso”</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Package “Tlasso”</h1>
<h4 class="author">Xiang Lyu, Will Wei Sun, Zhaoran Wang, Han Liu, Jian Yang, Guang Cheng.</h4>
<h4 class="date">2022-01-31</h4>



<p><a id="top"></a></p>
<blockquote>
<p><a href="#basic">Basic Info</a></p>
</blockquote>
<blockquote>
<p><a href="#method">Methodology</a></p>
</blockquote>
<blockquote>
<p><a href="#func">Functions</a></p>
</blockquote>
<blockquote>
<p><a href="#quick">Quick Start</a></p>
</blockquote>
<blockquote>
<p><a href="#ref">Reference</a></p>
</blockquote>
<p><a id="basic"></a></p>
<div id="basic-info" class="section level2">
<h2>Basic Info</h2>
<p>This package considers the estimation and inference of sparse graphical models that characterize the dependency structure of high-dimensional tensor-valued data. Data are assumed to follow a tensor normal distribution whose covariance has a Kronecker product structure. For estimation, this package provides an alternating minimization algorithm, which iteratively estimates each sparse precision matrix while fixing the others, and attains an estimator with the optimal statistical rate of convergence. Notably, such an estimator achieves estimation consistency with only one tensor sample, which is unobserved in previous work. For inference, this package provides a large-scale multiple testing method for support recovery of sparse precision matrix. A FDR control procedure can be easily implmented into the inference. Test consistency and FDR convergence achieves with only two tensor samples.</p>
<p><a id="method"></a></p>
</div>
<div id="methodology" class="section level2">
<h2>Methodology</h2>
<div id="estimation-tlasso-algorithm.-lyu-et-al.-20193" class="section level3">
<h3>Estimation: Tlasso Algorithm. <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a></h3>
<p>A tensor <span class="math inline">\({\cal T} \in \mathbb R^{m_1 \times m_2 \times \cdots \times m_K}\)</span> follows the tensor normal distribution with zero mean and covariance matrices <span class="math inline">\(\bf{\Sigma}_1, \ldots, \bf{\Sigma}_K\)</span>, denoted as <span class="math inline">\({\cal T} \sim \textrm{TN}({\bf0}; \bf{\Sigma}_1, \ldots, \bf{\Sigma}_K)\)</span>, if its probability density function is <span class="math display">\[
p({\cal T}| \bf{\Sigma}_1,\ldots,\bf{\Sigma}_K) = (2\pi)^{-m/2} \biggl\{ \prod_{k=1}^K |\bf{\Sigma}_k|^{-m/(2m_k)}  \biggr\} \exp \big(- \|{\cal T} \times \bf{\Sigma}^{-1/2}\|_F^2/2 \big),
\]</span> where <span class="math inline">\(m = \prod_{k=1}^K m_k\)</span> and <span class="math inline">\(\bf{\Sigma}^{-1/2} := \{\bf{\Sigma}_1^{-1/2},\ldots,\bf{\Sigma}_K^{-1/2}\}\)</span>.</p>
<p>A standard approach to estimate precision matrix <span class="math inline">\(\bf{\Omega}_k^*\)</span>, <span class="math inline">\(k=1,\ldots,K\)</span>, is to use the maximum likelihood method. Up to a constant, the negative log-likelihood function of the tensor normal distribution is <span class="math display">\[
\ell(\bf{\Omega}_1, \ldots, \bf{\Omega}_K) := \frac{1}{2}\textrm{tr}[\bf{S} (\bf{\Omega}_K \otimes \cdots \otimes \bf{\Omega}_1)] - \frac{1}{2}\sum_{k=1}^K \frac{m}{m_k} \log |\bf{\Omega}_k|,
\]</span> where <span class="math inline">\(\bf{S} := \frac{1}{n} \sum_{i=1}^n \textrm{vec}({\cal T}_i) \textrm{vec}({\cal T}_i)^{\top}\)</span>. To encourage the sparsity of each precision matrix in the high-dimensional scenario, a penalized log-likelihood estimator is proposed which minimizes <span class="math display">\[
q_n(\bf{\Omega}_1, \ldots, \bf{\Omega}_K) :=  \frac{1}{m}\textrm{tr}[\bf{S} (\bf{\Omega}_K \otimes \cdots \otimes \bf{\Omega}_1)] - \sum_{k=1}^K \frac{1}{m_k} \log |\bf{\Omega}_k| + \sum_{k=1}^K P_{\lambda_k}(\bf{\Omega}_k),
\]</span> where <span class="math inline">\(P_{\lambda_k}(\bf{\Omega}_k) = \lambda_k \sum_{i\ne j} |[\bf{\Omega}_{k}]_{i,j}|\)</span> is penalty function and <span class="math inline">\(\lambda_k\)</span> is tuning parameter.</p>
<p><span class="math inline">\(q_n(\bf{\Omega}_1, \ldots, \bf{\Omega}_K)\)</span> is jointly non-convex with respect to <span class="math inline">\(\bf{\Omega}_1, \ldots, \bf{\Omega}_K\)</span>. Nevertheless, <span class="math inline">\(q_n(\bf{\Omega}_1, \ldots, \bf{\Omega}_K)\)</span> is bi-convex problem since <span class="math inline">\(q_n(\bf{\Omega}_1, \ldots, \bf{\Omega}_K)\)</span> is convex in <span class="math inline">\(\bf{\Omega}_k\)</span> when the rest <span class="math inline">\(K-1\)</span> precision matrices are fixed. According to its bi-convex property, this package solves this non-convex problem by alternatively update one precision matrix with other matrices fixed. Note that, for any <span class="math inline">\(k = 1,\ldots, K\)</span>, minimizing <span class="math inline">\(q_n(\bf{\Omega}_1, \ldots, \bf{\Omega}_K)\)</span> with respect to <span class="math inline">\(\bf{\Omega}_k\)</span> while fixing the rest <span class="math inline">\(K-1\)</span> precision matrices is equivalent to minimizing <span class="math display">\[
L(\bf{\Omega}_k) :=  \frac{1}{m_k}\textrm{tr}(\bf{S}_k \bf{\Omega}_k) - \frac{1}{m_k} \log |\bf{\Omega}_k| + \lambda_k \|\bf{\Omega}_k\|_{1,\textrm{off}}. 
\]</span> Here <span class="math inline">\(\bf{S}_k := \frac{m_k}{n m}\sum_{i=1}^n \bf{V}_i^k \bf{V}_i^{k\top}\)</span>, where <span class="math inline">\(\bf{V}_i^k := \big[ {\cal T}_i \times \big\{\bf{\Omega}_1^{1/2},\ldots,\bf{\Omega}_{k-1}^{1/2}, 1_{m_k}, \bf{\Omega}_{k+1}^{1/2},\ldots,\bf{\Omega}_{K}^{1/2} \big\} \big]_{(k)}\)</span> with <span class="math inline">\(\times\)</span> the tensor product operation and <span class="math inline">\([\cdot]_{(k)}\)</span> the mode-<span class="math inline">\(k\)</span> matricization operation defined in . Note that minimizing <span class="math inline">\(L(\bf{\Omega}_k)\)</span> corresponds to estimating vector-valued Gaussian graphical model and can be solved efficiently via the glasso algorithm <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3019769/">Friedman et al. (2008)</a>. See <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> for detailed algorithm, named <strong>Tlasso</strong>.</p>
</div>
<div id="inference" class="section level3">
<h3>Inference:</h3>
<p>Multiple testing method is established to testing the entries of precision matrix for each way of the tensor, <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a>. We focus on <span class="math inline">\(\bf{\Omega}_1^*\)</span>, and procedures on the rest <span class="math inline">\(K-1\)</span> precision matrices are symmetric. Hypothesis for <span class="math inline">\(\bf{\Omega}_1^*\)</span> is, <span class="math inline">\(\forall \,1 \le i &lt; j \le m_1\)</span>, <span class="math display">\[
H_{0 1 , i j } : \;  [{\bf{\Omega}}_1^*]_{i,j} =0  \quad\quad \textrm{vs} \quad\quad H_{11 , ij} : \;  [\bf{\Omega}_1^*]_{i,j} \ne  0 
\]</span></p>
<p>Let index <span class="math inline">\(-i\)</span> in <span class="math inline">\(k\)</span>-th mode denote all elements of mode-<span class="math inline">\(k\)</span> except the <span class="math inline">\(i\)</span>-th one. From the distribution of <span class="math inline">\({\cal T }_{: , i_2 , \ldots , i_K}\)</span>, we have, for every <span class="math inline">\(i_k \in \{ 1 , \ldots , m_k\}\)</span>, <span class="math inline">\(k \in \{ 1 , \ldots , K\}\)</span>, <span class="math inline">\({\cal T}_{i_1 , i_2 , \ldots , i_K} | {\cal T}_{-i_1 , i_2 , \ldots , i_K} \sim \textrm{N} ( - [\bf{\Omega}_1^*]_{i_1,i_1}^{-1} [\bf{\Omega}_1^*]_{i_1, - i_1} {\cal T}_{-i_1 , i_2 , \ldots , i_K} ; [\bf{\Omega}_1^*]_{i_1, i_1 }^{-1} \prod_{k=2}^K[\bf{\Sigma}_k^*]_{i_k, i_k} )\)</span>. An equivalent linear model is <span class="math display">\[
{\cal T }_{l ; i_1, i_2 , \ldots , i_K} = {\cal T }_{l ; - i_1, i_2 , \ldots , i_K}^\top \bf{\theta}_{i_1} + \xi_{l ; i_1, i_2 , \ldots , i_K},  \forall \, l \in \{ 1 , \ldots , n \} 
\]</span> where <span class="math inline">\(\bf{\theta}_{i_1} = - [\bf{\Omega}_1^*]_{i_1,i_1}^{-1} [\bf{\Omega}_1^*]_{i_1, - i_1} \text{  , and  }\, \xi_{l ;i_1, i_2 , \ldots , i_K} \sim \textrm{N} (0 \, ; [\bf{\Omega}_1^*]_{i_1, i_1 }^{-1} \prod_{k=2}^K [\bf{\Sigma}_k^*]_{i_k, i_k}).\)</span> Note that intercept term is eliminated since zero mean of <span class="math inline">\({\cal T }_{: , i_2 , \ldots , i_K}\)</span>.</p>
<p>Test statistic is constructed by both bias and variance correction of sample covariance of residuals. Let <span class="math inline">\(\hat{\bf{\theta}}_{i_1} = (\hat{\theta}_{1, i_1} , \ldots , \hat{\theta}_{m_1-1, i_1})^\top = - [\hat{\bf{\Omega}}_1]_{i_1,i_1}^{-1} [\hat{\bf{\Omega}}_1]_{i_1, - i_1}\)</span> be the estimator of <span class="math inline">\(\bf{\theta}_{i_1}\)</span>, where <span class="math inline">\(\hat{\bf{\Omega}}_1\)</span> is the output of <strong>Tlasso</strong> Algorithm. Given <span class="math inline">\(\{ \hat{\bf{\theta}}_{i_1} \}_{i_1 = 1 }^{m_1}\)</span>, the residual of the linear model is defined as <span class="math display">\[
\hat{\xi}_{l ; i_1, i_2 , \ldots , i_K} = {\cal T }_{l ; i_1, i_2 , \ldots , i_K} - \bar{{\cal T }}_{ i_1, i_2 , \ldots , i_K} - ( {\cal T }_{l ; - i_1, i_2 , \ldots , i_K} - \bar{{\cal T }}_{ - i_1, i_2 , \ldots , i_K} )^\top \hat{\bf{\theta}}_{i_1},
\]</span> where <span class="math inline">\(\bar{{\cal T }} = \frac{1}{n}\sum \limits_{l=1}^{n} {\cal T }_{l }\)</span>. The sample covariance of residuals is<br />
<span class="math display">\[
\hat{\varrho}_{i,j}= \frac{m_1}{(n-1) m } \sum \limits_{l=1}^{n} \sum \limits_{i_2=1}^{m_2} \cdots \sum \limits_{i_K=1}^{m_K}  \hat{\xi}_{l ; i, i_2 , \ldots , i_K} \hat{\xi}_{l ; j, i_2 , \ldots , i_K} .
\]</span> Test statistic is <span class="math display">\[\tau_{i,j} = \frac{\hat{\varrho}_{i.j} + \mu_{i,j}}{\varpi}, \forall 1 \le i &lt; j \le m_1.\]</span> The bias correction term <span class="math inline">\(\mu_{i,j}=\hat{\varrho}_{i,i} \hat{\theta}_{i , j} + \hat{\varrho}_{j,j} \hat{\theta}_{j-1, i}\)</span> translates the mean of <span class="math inline">\(\tau_{i,j}\)</span> to zero under <span class="math inline">\(H_{01, ij}\)</span>. The variance correction term <span class="math display">\[
\varpi^2 =  \frac{m \cdot \|\widehat{\bf{S}}_2\|_F^2 \cdots \|\widehat{\bf{S}}_K\|_F^2}{m_1 \cdot (\textrm{tr}(\widehat{\bf{S}}_2))^2 \cdots (\textrm{tr}(\widehat{\bf{S}}_K))^2}, 
\]</span> plays a significant role in rescaling <span class="math inline">\(\tau_{i,j}\)</span> into an asymptotic standard normal distribution, where $ <em>k :=  </em>{i=1}^n _i _i^{} $ is the estimate of <span class="math inline">\(\bf{\Sigma}_k\)</span> with <span class="math inline">\(\widehat{\bf{V}}_i := \big[ {\cal T}_i \times \bigl\{\widehat{\bf{\Omega}}_1^{1/2},\ldots,\widehat{\bf{\Omega}}_{k-1}^{1/2}, 1_{m_k}, \widehat{\bf{\Omega}}_{k+1}^{1/2},\ldots,\widehat{\bf{\Omega}}_{K}^{1/2} \bigr\} \big]_{(k)}\)</span> and <span class="math inline">\(\widehat{\bf{\Omega}}_{k}\)</span> from <strong>Tlasso</strong> Algorithm, <span class="math inline">\(k \in \{2 , \ldots , K \}\)</span>. <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> proves that, under certain conditions, <span class="math display">\[ \sqrt{\frac{(n-1) m  }{ m_1 \hat{\varrho}_{i,i} \hat{\varrho}_{j,j} }} \tau_{i,j}  \rightarrow \textrm{N} ( 0 ;1 ) \]</span> in distribution, as <span class="math inline">\(nm/m_1 \rightarrow \infty\)</span>.</p>
<p>Let <span class="math inline">\(\tilde{\tau}_{i,j}= \sqrt{(n-1) m/ (m_1\hat{\varrho}_{i,i} \hat{\varrho}_{j,j}) } \tau_{i,j}\)</span>. Given the values of <span class="math inline">\(\tilde{\tau}_{ij}\)</span> and thresholding level <span class="math inline">\(\varsigma\)</span>, we define a test procedure <span class="math inline">\(\varphi_{\varsigma} (\tilde{\tau}_{i,j})= 1 \{ |\tilde{\tau}_{i,j}| \ge \varsigma \}\)</span> and reject <span class="math inline">\(H_{01, ij}\)</span> if <span class="math inline">\(\varphi_{\varsigma} (\tilde{\tau}_{i,j})=1\)</span>. The definition of FDR/FDP in our notation is <span class="math display">\[
\textrm{FDP} = \frac{| \{ (i,j) \in {\cal H}_0 : \varphi_{\varsigma} (\tilde{\tau}_{i,j})=1 \} | }{ | \{ (i,j)  : 1 \le i &lt; j \le m_1, \varphi_{\varsigma} (\tilde{\tau}_{i,j})=1 \} |  \vee 1 } \, \text{ , and } \,\textrm{FDR} = \bf{E} (\textrm{FDP}).
\]</span> where <span class="math inline">\({\cal H}_0 = \{ (i,j) : [\bf{\Omega}_1^*]_{i,j} = 0 , 1 \le i &lt; j \le m_1 \}\)</span>. To recover the support of <span class="math inline">\(\bf{\Omega}_1^*\)</span>, <span class="math inline">\((m_1-1)m_1/2\)</span> tests are simultaneously conducted. Hence, a small enough <span class="math inline">\(\varsigma\)</span> that enhances power while controls FDP under a pre-specific level <span class="math inline">\(\upsilon \in (0,1)\)</span> is an ideal choice. In particular, <span class="math inline">\(\varsigma_{*} = \inf \{ \varsigma &gt; 0: \text{FDP} \le \upsilon \}\)</span>. However, <span class="math inline">\(\varsigma_*\)</span> is oracle since we have no access to the information of <span class="math inline">\({\cal H}_0\)</span>. Due to sparsity, <span class="math inline">\(w_0 =|{\cal H}_0|\)</span> can be approximated by <span class="math inline">\(w= m_1(m_1 -1 )/2\)</span>. <span class="math inline">\(P(\varphi_{\varsigma} (\tilde{\tau}_{i,j})=1)\)</span> is close to <span class="math inline">\(2(1 - \Phi( \varsigma))\)</span> by test consistency. The approximation of <span class="math inline">\(\varsigma_*\)</span> is <span class="math display">\[
\hat{\varsigma}= \inf \bigg \{   \varsigma &gt; 0: \frac{2(1-\Phi( \varsigma )) w}{  | \{ (i,j)  : 1 \le i &lt; j \le m_1,  \varphi_{\varsigma} (\tilde{\tau}_{i,j})=1 \} | \vee 1 } \le \upsilon  \bigg \}.
\]</span></p>
<p>FDR/FDP control procedure is to infer the support of <span class="math inline">\(\bf{\Omega}_1^*\)</span> at thresholding level <span class="math inline">\(\hat{\varsigma}\)</span>. In particular, FDR and FDP in the procedure are <span class="math display">\[
\textrm{FDP}_1 = \frac{| \{ (i,j) \in {\cal H}_0 : \varphi_{\hat{\varsigma}} (\tilde{\tau}_{i,j})=1 \} | }{ | \{ (i,j)  : 1 \le i &lt; j \le m_1, \varphi_{\hat{\varsigma}} (\tilde{\tau}_{i,j})=1 \} | \vee 1 } \text{ , and } \,\textrm{FDR}_1 = \bf{E} (\textrm{FDP}_1). 
\]</span> Note that we set <span class="math inline">\(\tilde{\tau}_{i,j} = \tilde{\tau}_{j,i}\)</span> for <span class="math inline">\(1 \le i &lt; j \le m_1\)</span>. The inference of <span class="math inline">\(\textrm{supp}(\bf{\Omega}_k^*) , \, k \in \{2 , \ldots , K \}\)</span>, is a symmetric procedure.</p>
<p><a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> gives the asymptotic control of <span class="math inline">\(\text{FDP}_1\)</span> and <span class="math inline">\(\text{FDR}_1\)</span> for the support of <span class="math inline">\(\bf{\Omega}_{1}^*\)</span>: under certain conditions, <span class="math display">\[\textrm{FDP}_1 w / \upsilon w_0 \rightarrow 1 , \; \textrm{FDR}_1  w / \upsilon w_0 \rightarrow 1 \]</span> in probability as <span class="math inline">\(nm/m_1 \rightarrow \infty\)</span>.</p>
<p><a href="#top">Back to Top</a></p>
<p><a id="func"></a></p>
</div>
</div>
<div id="functions" class="section level2">
<h2>Functions</h2>
<p>This packages contains following functions:</p>
<ol style="list-style-type: decimal">
<li><dl>
<dt><code>ChainOmega</code></dt>
<dd>This function generates precision matrix of triangle graph (chain like network) following the set-up in <a href="https://arxiv.org/abs/0908.2053">Fan et al. (2009)</a>. It first constructs a covariance matrix <span class="math inline">\(\Sigma\)</span> that its (i,j) entry is <span class="math inline">\(\exp (- | h_i - h_j |/2)\)</span> with <span class="math inline">\(h_1 &lt; h_2 &lt; \ldots &lt; h_p\)</span>. The difference <span class="math inline">\(h_i - h_{i+1}\)</span> is generated i.i.d. from Unif(0.5,1). See <a href="https://arxiv.org/abs/0908.2053">Fan et al. (2009)</a> for more details.
</dd>
</dl></li>
<li><dl>
<dt><code>NeighborOmega</code></dt>
<dd>This function generates precision matrix of nearest neighbor network following the set-up in <a href="https://paperity.org/p/38773767/gradient-directed-regularization-for-sparse-gaussian-concentration-graphs-with">Li and Gui (2006)</a> and <a href="https://jmlr.org/papers/v16/lee15a.html">Lee and Liu (2006)</a>. For a <code>knn</code> nearest-neighbor graph, this function first randomly picks p points from a unit square and computes all pairwise distances among the points. Then it searches for the knn nearest-neighbors of each point and a pair of symmetric entries in the precision matrix that has a random chosen value from <span class="math inline">\([-1, -0.5] \cup [0.5, 1]\)</span>. Finally, to ensure positive definite property, it normalizes the matrix as <span class="math inline">\(\Omega &lt;- \Omega + (\lambda_{\min} (\Omega) + 0.2 ) 1_p\)</span> where <span class="math inline">\(\lambda_{\min} (\cdot )\)</span> refers to the samllest eigenvalue.
</dd>
</dl></li>
<li><dl>
<dt><code>Trnorm</code></dt>
<dd>This function generates obeservations from separable tensor normal distribution and returns a <span class="math inline">\(m_1 * \ldots * m_K * n\)</span> array. If <code>Sigma.list</code> is not given, default distribution is from either triangle graph or nearest-neighbor graph (depends on <code>type</code>).
</dd>
</dl></li>
<li><dl>
<dt><code>Tlasso.fit</code></dt>
<dd>This function conducts an alternating optimization algorithm to precision matrices of sparse tensor graphical models. The output is optimal consistent even when <span class="math inline">\(T=1\)</span>, see <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> for details. There are two ternimation criteria, <code>T</code> and <code>thres</code>. Algorithm will be terminated if output in certain iteration change less than <code>thres</code>. Otherwise, T iterations will be fully operated.
</dd>
</dl></li>
<li><dl>
<dt><code>covres</code></dt>
<dd>This function generates sample covariance matrix of residuals (includes diagnoal) and is the basis for support recovery procedure, see <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a>. Note that output matrix includes diagnoal while bias corrected matrix (output of <code>biascor</code>) for inference is off-diagnoal. Elements in Omega.list are true precision matrices or estimation of the true ones, the latter can be output of <code>Tlasso.fit</code>.
</dd>
</dl></li>
<li><dl>
<dt><code>biascor</code></dt>
<dd>This function computes bias corrected sample covariance matrix of residuals (excludes diagnoal, diagnoal is zero vector). Note that output matrix excludes diagnoal while sample covariance of residuals includes diagnoal, see <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> for details. Elements in <code>Omega.list</code> are true precision matrices or estimation of the true ones, the latter can be output of <code>Tlasso.fit</code>.
</dd>
</dl></li>
<li><dl>
<dt><code>varcor</code></dt>
<dd>This function computes variance correction term of sample covariance of residuals and is utilized to normalize test statistic into standord normal, see <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> for details.
</dd>
</dl></li>
<li><dl>
<dt><code>est.analysis</code></dt>
<dd>This function generates a list of performance measures of optimazation for sparse tensor graphical models, i.e., estimation errors and model selection consistency. Errors are measured in Frobenius norm and Max norm. Model selection measures are TPR and TNR. All these measures are computed in each mode, average across all modes, and kronecker production of precision matrices.
</dd>
</dl></li>
<li><dl>
<dt><code>infer.analysis</code></dt>
<dd>This function computes performance measures of inference for sparse tensor graphical models. False positive, false negative, discovery (number of rejected null hypothesis), non-discovery (number of non-rejected null hypothesis), and total non-zero entries of each true precision matrix is listed in output.
</dd>
</dl></li>
<li><dl>
<dt><code>graph.pattern</code></dt>
<dd>This function draws an undirected graph based on presicion matrix to present connection among variables. If an entry is zero, then no edge is connected between corresponding pair of nodes.
</dd>
</dl></li>
</ol>
<p><a href="#top">Back to Top</a></p>
<p><a id="quick"></a></p>
</div>
<div id="quick-start" class="section level2">
<h2>Quick Start</h2>
<p>The purpose of this section is to show users the basic usage of this package. We will briefly go through main functions, see what they can do and have a look at outputs. An detailed example of complete procedures of estimation and inference will be presented to give users a general sense of the pakcage.</p>
<p>First, we load <code>Tlasso</code> package:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(Tlasso)</a></code></pre></div>
<p>Then, we generate a list of precision matrices of triangle graph.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">m.vec =<span class="st"> </span><span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>)  <span class="co"># dimensionality of a tensor </span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co"># m1, m2, m3</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">n =<span class="st"> </span><span class="dv">5</span>   <span class="co"># sample size </span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">Omega.true.list =<span class="st"> </span><span class="kw">list</span>()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(m.vec)) {</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  Omega.true.list[[k]] =<span class="st"> </span><span class="kw">ChainOmega</span>(m.vec[k], <span class="dt">sd =</span> k)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">Omega.true.list[[<span class="dv">1</span>]]</a></code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]       [,5]
## [1,]  0.3168143 -0.2308893  0.0000000  0.0000000  0.0000000
## [2,] -0.2308893  0.4674875 -0.2123306  0.0000000  0.0000000
## [3,]  0.0000000 -0.2123306  0.4234692 -0.1841058  0.0000000
## [4,]  0.0000000  0.0000000 -0.1841058  0.3658496 -0.1499391
## [5,]  0.0000000  0.0000000  0.0000000 -0.1499391  0.2415995</code></pre>
<p><code>ChainOmega</code> returns a precision matrix of triangle graph with dimension <code>m.vec[k]</code> and seed number <code>k</code>. Given precision matrices, we generate obervations from corresponding tensor normal distribution.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">Sigma.true.list =<span class="st"> </span><span class="kw">list</span>()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(m.vec)) {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  Sigma.true.list[[k]] =<span class="st"> </span><span class="kw">solve</span>(Omega.true.list[[k]])</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">} <span class="co"># generate covariance matrices list</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">DATA=<span class="kw">Trnorm</span>(n,m.vec,<span class="dt">Sigma.list=</span>Sigma.true.list) </a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co"># obersavations from tensor normal distribution</span></a></code></pre></div>
<p><code>Trnorm</code> generates observations from separable tensor normal distribution with covariance matrix <code>Sigma.list[[k]]</code> for kth mode. <code>DATA</code> is a <span class="math inline">\(m_1 * m_2 * m_3 * n\)</span> array, i.e, a <span class="math inline">\(10 \times 10 \times 10 \times 10\)</span> array. Default distribution is from triangle graph or 4 near-neighbor graph (depends on <code>type</code>).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">DATA2=<span class="kw">Trnorm</span>(n,m.vec)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co"># default is triangle graph </span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co"># equivalent to DATA2 = Trnorm(n,m.vec, type='Chain', sd=1)</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">DATA3=<span class="kw">Trnorm</span>(n,m.vec,<span class="dt">type=</span><span class="st">'Neighbor'</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co"># 4 nearest-neighbor graph</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="co"># equivalent to DATA3 = Trnorm(n,m.vec, type='Neighbor', sd=1, knn=4)</span></a></code></pre></div>
<p>Given observations <code>DATA</code>, we use <code>Tlasso.fit</code> to conduct alternating optimization.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">lambda.thm =<span class="st"> </span><span class="dv">20</span><span class="op">*</span><span class="kw">c</span>( <span class="kw">sqrt</span>(<span class="kw">log</span>(m.vec[<span class="dv">1</span>])<span class="op">/</span>(n<span class="op">*</span><span class="kw">prod</span>(m.vec))), </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">                   <span class="kw">sqrt</span>(<span class="kw">log</span>(m.vec[<span class="dv">2</span>])<span class="op">/</span>(n<span class="op">*</span><span class="kw">prod</span>(m.vec))), </a>
<a class="sourceLine" id="cb6-3" data-line-number="3">                   <span class="kw">sqrt</span>(<span class="kw">log</span>(m.vec[<span class="dv">3</span>])<span class="op">/</span>(n<span class="op">*</span><span class="kw">prod</span>(m.vec))))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co"># lambda.thm is regularization parameter</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">out.tlasso =<span class="st"> </span><span class="kw">Tlasso.fit</span>(DATA,<span class="dt">T=</span><span class="dv">1</span>,<span class="dt">lambda.vec =</span> lambda.thm)   </a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co"># output is a list of estimation of precision matrices</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">out.tlasso[[<span class="dv">1</span>]]</a></code></pre></div>
<pre><code>##              [,1]        [,2]         [,3]        [,4]        [,5]
## [1,]  0.361422637 -0.23704270  0.002333856 -0.06126152  0.01539202
## [2,] -0.237046526  0.46822624 -0.192384949 -0.05154091  0.05256162
## [3,]  0.002304876 -0.19236551  0.424993048 -0.17817458 -0.07814616
## [4,] -0.061257515 -0.05155747 -0.178173408  0.37108685 -0.08295747
## [5,]  0.015405071  0.05255995 -0.078142842 -0.08296053  0.19265707</code></pre>
<p><code>Tlasso.fit</code> generates a list of precision matrices <code>out.tlasso</code>. Default is maximal iteration <code>T=1</code> and termination thresholding level <code>thres=1e-05</code>. If estimation output changes less than <code>thres</code>, in terms of Frobenius norm, after certain iteration, <code>Tlasso.fit</code> will be terminated immediately (before Tth iteration). The performance of <code>Tlasso.fit</code> can be evaluated by <code>est.analysis</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co"># compare out.tlasso and Omega.true.list</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co"># main diagnoal is taken into consideration</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">est.analysis</span>(out.tlasso,Omega.true.list,<span class="dt">offdiag=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>## $error.kro
## [1] 0.3656762
## 
## $tpr.kro
## [1] 1
## 
## $tnr.kro
## [1] 0.4989574
## 
## $av.error.f
## [1] 0.1986636
## 
## $av.error.max
## [1] 0.08618703
## 
## $av.tpr
## [1] 1
## 
## $av.tnr
## [1] 0.3333333
## 
## $error.f
## [1] 0.2130124 0.0980819 0.2848964
## 
## $error.max
## [1] 0.07814616 0.05873962 0.12167531
## 
## $tpr
## [1] 1 1 1
## 
## $tnr
## [1] 0.0000000 0.3333333 0.6666667</code></pre>
<p><code>est.analysis</code> returns a list of estimation performance measures:</p>
<table>
<thead>
<tr class="header">
<th>Argument</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Out$error.kro</code></td>
<td>error in Frobenius norm of kronecker product</td>
</tr>
<tr class="even">
<td><code>Out$tpr.kro</code></td>
<td>TPR of kronecker product</td>
</tr>
<tr class="odd">
<td><code>Out$tnr.kro</code></td>
<td>TNR of kronecker product</td>
</tr>
<tr class="even">
<td><code>Out$av.error.f</code></td>
<td>averaged Frobenius norm error across all modes</td>
</tr>
<tr class="odd">
<td><code>Out$av.error.max</code></td>
<td>averaged Max norm error across all modes</td>
</tr>
<tr class="even">
<td><code>Out$av.tpr</code></td>
<td>averaged TPR across all modes</td>
</tr>
<tr class="odd">
<td><code>Out$av.tnr</code></td>
<td>averaged TNR across all modes</td>
</tr>
<tr class="even">
<td><code>Out$error.f</code></td>
<td>vector; error in Frobenius norm of each mode</td>
</tr>
<tr class="odd">
<td><code>Out$error.max</code></td>
<td>vector; error in Max norm of each mode</td>
</tr>
<tr class="even">
<td><code>Out$tpr</code></td>
<td>vector; TPR of each mode</td>
</tr>
<tr class="odd">
<td><code>Out$tnr</code></td>
<td>vector; TNR of each mode</td>
</tr>
</tbody>
</table>
<p>Given <code>DATA</code> and <code>out.tlasso</code>, we next show how to compute test statistic.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">mat.list=<span class="kw">list</span>() <span class="co"># list of matrices of test statistic value  </span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="cf">for</span> ( k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(m.vec)) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  rho=<span class="kw">covres</span>(DATA, out.tlasso, <span class="dt">k =</span> k) </a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="co"># sample covariance matrix of residuals, including diagnoal </span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  bias_rho=<span class="kw">biascor</span>(rho,out.tlasso,<span class="dt">k=</span>k)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="co"># bias corrected sample covariance of residuals, excluding diagnoal</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  varpi2=<span class="kw">varcor</span>(DATA, out.tlasso, <span class="dt">k =</span> k)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  <span class="co"># variance correction term for kth mode's sample covariance of residuals</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  tautest=<span class="kw">matrix</span>(<span class="dv">0</span>,m.vec[k],m.vec[k])</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">  <span class="cf">for</span>( i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(m.vec[k]<span class="op">-</span><span class="dv">1</span>)) {</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    <span class="cf">for</span> ( j <span class="cf">in</span> (i<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>m.vec[k]){</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">      tautest[j,i]=tautest[i,j]=<span class="kw">sqrt</span>((n<span class="dv">-1</span>)<span class="op">*</span><span class="kw">prod</span>(m.vec[<span class="op">-</span>k]))<span class="op">*</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="st">                      </span>bias_rho[i,j]<span class="op">/</span><span class="kw">sqrt</span>(varpi2<span class="op">*</span>rho[i,i]<span class="op">*</span>rho[j,j])</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">      <span class="co"># compute final test statistic </span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">  </a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  mat.list[[k]]=tautest</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">}</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">mat.list[[<span class="dv">1</span>]]</a></code></pre></div>
<pre><code>##            [,1]      [,2]      [,3]     [,4]       [,5]
## [1,]  0.0000000  2.761395 -0.231802 1.509672 -0.4881653
## [2,]  2.7613945  0.000000  2.411092 0.797850 -1.2962198
## [3,] -0.2318020  2.411092  0.000000 2.153166  1.2980072
## [4,]  1.5096719  0.797850  2.153166 0.000000  2.3900777
## [5,] -0.4881653 -1.296220  1.298007 2.390078  0.0000000</code></pre>
<p>To compute test statistic, we first need to compute sample covariance of residuals via <code>rho</code>. <code>rho</code> returns a sample covariance matrix, including diagnoal. Then we conduct bias correction <code>biascor</code> and variance correction <code>varcor</code>. <code>biascor</code> returns a bias corrected sample covariance matrix. <code>varcor</code> returns a scalar to scale test statistic into standard normal. Given test statistic value <code>mat.list</code>, we turn to test hypothesis. The significant level we choose is <span class="math inline">\(0.95\)</span>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co"># inference measures (off-diagnoal), critical value is 0.975 quantile of standard normal</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">infer.analysis</span>(mat.list, <span class="kw">qnorm</span>(<span class="fl">0.975</span>), Omega.true.list, <span class="dt">offdiag=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## $fp
## [1] 0 0 2
## 
## $fn
## [1] 0 0 4
## 
## $d
## [1] 8 8 6
## 
## $nd
## [1] 12 12 14
## 
## $t
## [1] 8 8 8</code></pre>
<p><code>infer.analysis</code> returns a list of inference performance measures:</p>
<table>
<thead>
<tr class="header">
<th>Argument</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Out$fp</code></td>
<td>vector; number of false positive of each mode</td>
</tr>
<tr class="even">
<td><code>Out$fn</code></td>
<td>vector; number of false negative of each mode</td>
</tr>
<tr class="odd">
<td><code>Out$d</code></td>
<td>vector; number of all discovery of each mode</td>
</tr>
<tr class="even">
<td><code>Out$nd</code></td>
<td>vector; number of all non-discovery of each mode</td>
</tr>
<tr class="odd">
<td><code>Out$t</code></td>
<td>vector; number of all true non-zero entries of each mode</td>
</tr>
</tbody>
</table>
<p>Due to the fact that this inference procedure relies on multiple testing, FDR control is indispensible. <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> provides an easy-implemented and efficient FDR control procedure. This procedure asymptotically controls FDR via selecting the smallest critical value that contrains FDP under certain level.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">k=<span class="dv">1</span> <span class="co"># interested mode </span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">upsilon=<span class="fl">0.1</span>  <span class="co"># control level</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="co"># compute the difference between FDP and upsilon</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">fun=<span class="cf">function</span>(varsigma,mk,upsilon,tautest) {</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  <span class="kw">return</span>((<span class="dv">2</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">pnorm</span>(varsigma))<span class="op">*</span>mk<span class="op">*</span>(mk<span class="dv">-1</span>))<span class="op">/</span><span class="kw">max</span>(<span class="dv">1</span>,<span class="kw">sum</span>(<span class="kw">sign</span>(<span class="kw">abs</span>(tautest) <span class="op">&gt;</span><span class="st"> </span>varsigma))) <span class="op">-</span><span class="st"> </span>upsilon)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="co"># select a critical value in (0,6) that has the samllest difference </span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">diff=<span class="kw">c</span>();ind=<span class="dv">1</span>;inter=<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">6</span>,<span class="fl">0.0001</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="cf">for</span> (varsigma <span class="cf">in</span> inter) {</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    diff[ind]=<span class="kw">fun</span>(varsigma,<span class="dt">mk=</span>m.vec[k],<span class="dt">upsilon=</span>upsilon,<span class="dt">tautest=</span>mat.list[[k]])</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    ind=ind<span class="op">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="co"># the smallest critical value that constrains FDP under upsilon</span></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">critical=inter[<span class="kw">min</span>(<span class="kw">which</span>(diff <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>))]</a>
<a class="sourceLine" id="cb14-17" data-line-number="17"></a>
<a class="sourceLine" id="cb14-18" data-line-number="18"><span class="co"># testing hypothesis with the critcal value </span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19"><span class="co"># FDR will converge to the limit proved in Lyu et al. 2019.</span></a>
<a class="sourceLine" id="cb14-20" data-line-number="20">inference.FDR=<span class="kw">infer.analysis</span>(mat.list, critical, Omega.true.list, <span class="dt">offdiag=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>Finally, we would like to visualize graph structure of inference via <code>graph.pattern</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">k=<span class="dv">1</span> <span class="co"># interested mode</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co"># true graph structure. </span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co"># set thres=0 in case true edge is eliminated</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">graph.pattern</span>(Omega.true.list[[<span class="dv">1</span>]],<span class="dt">main=</span><span class="st">'True graph of mode 1'</span>,<span class="dt">thres=</span><span class="dv">0</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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2x133OHv65xoldL66/7p/TqrVf8l+b5XbrrpptTf/vY3t73Pfvazft+HDh3y++BGcgT0Mxk2BGIlkEsA6z+WDz/8cMo5izr129/+1p1HLgHsrLT8fwTvvffe1NGjR1Nbt271w6Br167ntUkP9RtvvNENSOewceprX/ua366O0dvSA7issU+YMMENXefkpdSpU6dSzkos5axm/bZWrVrlNpUewBocP/rRj1LOSU+pX/ziFylntefur78IOCc+ufunB7D+YuGsRN3Hda4XX3yxu3+nTp28YZb50zncnKpZs6a7r7MyTekvMc5h8tT3vvc9/5eOVq1apZxVpfu4c6jVH/eyZctS+noNyPI2L4DV5f77709p8DkfCZQKw6985Ssp53BxyjmrOqXz0H1HjBjhN3nPPff4fU6aNCnlnEyVeumll1J9+vTxH9dx6eac3ew/pr8wbNq0KaW1cz4C8R/X9r0Azve94g/y4xsEcKZI8u5/8i9D8ubOjGMqkEsA33XXXefMIpcAdj57dv+x1ZWgF1baYHrovf766+f04T2QHrSPPfaY97Abnt5KWP8R97b0AC5r7N5+Gr66OZ+jpr7//e/7gfCDH/zAfTw9gDN/SViyZIm//y9/+Ut3//QAHjx4sPuY9z+33nqru78G9/m21atX++1q4KdvGnY6T/3POUTtPqV9e4/97Gc/S9+9zNteAOsq1As93dE5lOy2o79oOGdz+6/VsNf20+fvfAzhPuZ8DOAGtbez/qLhjcU51O0+nF67Rx991NvV/en1qa/xxpLve6VUB84dAjhTJHn3cz/zwnlHsiEQF4Fu3bqVOxTn/86lnivrc723337b3UdPvLntttv8/fWzQW/TE37088SyNucfdv9h59Cnf9s5HOy25xxS9h/LvFHe2PU1el20c/jbPdko/XWZc9Ln9PPY9E0/v/a2LVu2eDf9n5mXAnknnB07dszfp6wbf/zjH/2Hhw4d6t/WG3p/3bp17mOvvvqqDBgwoNTzudy54oorSp0I5Rzadl+un+c6h4b9przrZr3Prt999133pDDdwfnlptQJWvpZdYcOHUTH9tprr+lvROL8UuK3pZdLpW/XXnut6KVI6Vu+75X0triNgAoQwLwPjBbQk2bK2/TM1vTN+4c6/TE9YUc3PZtWTxLyNr3tncTlrIC8h8/5mf4FDZlnEu/bt++c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" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">inf.mat=mat.list[[k]] <span class="op">&gt;</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="fl">0.975</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co"># set thres=0 (&lt;1) since inf.mat is logical</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">graph.pattern</span>(inf.mat,<span class="dt">main=</span><span class="st">'Inference of mode 1'</span>,<span class="dt">thres=</span><span class="dv">0</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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CGCzvtSOAAIIIICAVoAA1rJQiAACCCCAgFkBAtisL7UjgAACCCCgFSCAtSwUIoAAAgggYFaAADbrS+0IIIAAAghoBQhgLQuFCCCAAAIImBUggM36UjsCCCCAAAJaAQJYy0IhAggggAACZgUIYLO+1I4AAggggIBWgADWslCIAAIIIICAWQEC2KwvtSOAAAIIIKAVIIC1LBQigAACCCBgVoAANutL7QgggAACCGgFCGAtC4UIIIAAAgiYFSCAzfpSOwIIIIAAAloBAljLQiECCCCAAAJmBQhgs77UjgACCCCAgFaAANayUIgAAggggIBZAQLYrC+1I4AAAgggoBUggLUsFCKAAAIIIGBWgAA260vtCCCAAAIIaAUIYC0LhQgggAACCJgVIIDN+lI7AggggAACWgECWMtCIQIIIIAAAmYFCGCzvtSOAAIIIICAVoAA1rJQiAACCCCAgFkBAtisL7UjgAACCCCgFSCAtSwUIoAAAgggYFaAADbrS+0IIIAAAghoBQhgLQuFCCCAAAIImBUggM36UjsCCCCAAAJaAQJYy0IhAggggAACZgUIYLO+1I4AAggggIBWgADWslCIAAIIIICAWQEC2KwvtSOAAAIIIKAVIIC1LBQigAACCCBgVoAANutL7QgggAACCGgFCGAtC4UIIIAAAgiYFSCAzfpSOwIIIIAAAloBAljLQiECCCCAAAJmBQhgs77UjgACCCCAgFaAANayUIgAAggggIBZAQLYrC+1I4AAAgggoBUggLUsFCKAAAIIIGBWgAA260vtCCCAAAIIaAUIYC0LhQgggAACCJgVIIDN+lI7AggggAACWgECWMtCIQIIIIAAAmYFCGCzvtSOAAIIIICAVoAA1rJQiAACCCCAgFkBAtisL7UjgAACCCCgFSCAtSwUIoAAAgggYFaAADbrS+0IIIAAAghoBQhgLQuFCCCAAAIImBUggM36UjsCCCCAAAJaAQJYy0IhAggggAACZgUIYLO+1I4AAggggIBWgADWslCIAAIIIICAWQEC2KwvtSOAAAIIIKAVIIC1LBQigAACCCBgVoAANutL7QgggAACCGgFCGAtC4UIIIAAAgiYFSCAzfpSOwIIIIAAAloBAljLQiECCCCAAAJmBQhgs77UjgACCCCAgFaAANayUIgAAggggIBZAQLYrC+1I4AAAgggoBUggLUsFCKAAAIIIGBWgAA260vtCCCAAAIIaAUIYC0LhQgggAACCJgVIIDN+lI7AggggAACWgECWMtCIQIIIIAAAmYFCGCzvtSOAAIIIICAVoAA1rJQiAACCCCAgFkBAtisL7UjgAACCCCgFSCAtSwUIoAAAgggYFaAADbrS+0IIIAAAghoBQhgLQuFCCCAAAIImBUggM36UjsCCCCAAAJaAQJYy0IhAggggAACZgUIYLO+1I4AAggggIBWgADWslCIAAIIIICAWQEC2KwvtSOAAAIIIKAVIIC1LBQigAACCCBgVoAANutL7QgggAACCGgFCGAtC4UIIIAAAgiYFSCAzfpSOwIIIIAAAloBAljLQiECCCCAAAJmBQhgs77UjgACCCCAgFaAANayUIgAAggggIBZAQLYrC+1I4AAAgggoBUggLUsFCKAAAIIIGBWgAA260vtCCCAAAIIaAUIYC0LhQgggAACCJgVIIDN+lI7AggggAACWgECWMtCIQIIIIAAAmYFCGCzvtSOAAIIIICAVoAA1rJQiAACCCCAgFkBAtisL7UjgAACCCCgFSCAtSwUIoAAAgggYFaAADbrS+0IIIAAAghoBQhgLQuFCCCAAAIImBUggM36UjsCCCCAAAJagf8P5VeLNmjSUB8AAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<p>From graphs we can see that inference result quite matches true graph.</p>
<p><a href="#top">Back to Top</a></p>
<p><a id="ref"></a></p>
</div>
<div id="reference" class="section level2">
<h2>Reference</h2>
<ol style="list-style-type: decimal">
<li>Fan J, Feng Y, Wu Y. <em>Network exploration via the adaptive LASSO and SCAD penalties.</em> <strong><em>The annals of applied statistics</em></strong>, 2009, <strong>3(2): 521</strong>.</li>
<li>Friedman J, Hastie T, Tibshirani R. <em>Sparse inverse covariance estimation with the graphical lasso.</em> <strong><em>Biostatistics</em></strong>, 2008: <strong>9.3: 432-441</strong>.</li>
<li>Lee W, Liu Y. <em>Joint estimation of multiple precision matrices with common structures.</em> <strong><em>Journal of Machine Learning Research</em></strong>, 2015, <strong>16: 1035-1062</strong>.</li>
<li>Li H, Gui J. <em>Gradient directed regularization for sparse Gaussian concentration graphs, with applications to inference of genetic networks.</em> <strong><em>Biostatistics</em></strong>, 2006, <strong>7(2): 302-317</strong>.</li>
<li>Lyu, X., Sun, W. W., Wang, Z., Liu, H., Yang, J., Cheng, G. <em>Tensor graphical model: Non-convex optimization and statistical inference.</em> <strong><em>IEEE transactions on pattern analysis and machine intelligence</em></strong>, 2019: <strong>42(8): 2024-2037</strong>.</li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
